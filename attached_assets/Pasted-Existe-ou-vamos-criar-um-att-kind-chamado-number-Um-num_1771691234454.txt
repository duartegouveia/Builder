Existe (ou vamos criar) um att kind chamado "number".
Um number tem um sub atributo na definição da coluna ".number" que tem as seguintes propriedades
.group
.min
.max
.continuous
.step
.decimal_units
.autoincrement
.autoincrement_max
.show_thousands_separator
.show_spin_buttons
.associated_error:null | '5%' | '0.01' | 'input'

A propriedade group serve para indicar um dos domínios comuns da matemática: 'N' |'N0' | 'Z' | 'Z+' | 'Z-' | 'Z0+' | 'Z0-' | 'Q' | 'Q+' | 'Q-' | 'Q0+' | 'Q0-' | 'R' | 'R+' | 'R-' | 'R0+' | 'R0-' | 'C'
Por omissão o grupo é 'R', que é o caso mais geral.
Esse domínio pode ainda ser mais restrito com os atributos min e max, que por omissão ficam a null (ou vazio).
O atributo booleano "continuous", serve para indicar se estamos a utilizar números continuos ou discretos. Por omissão quando no grupo temos 'N', 'Z' (ou variantes) temos continuous a false. Quando temos 'Q', 'R', ou 'C', temos por omissão contínuos, mas pode dar-se o caso de ser um destes domínios aparentemente contínuos mas só estarem a ser utilizador valores discretos.
Consoante os dados são contínuos ou discretos podem ser utilizados métodos estatísticos diferentes na análise.

O atributo step, serve para indicar um intervalo mínimo entre os valores. Por exemplo, se for utilizado 0.25 em .step, então são válidos os valores de 12, 13.25, 14.5, 14.75 . Mas não são válidos os valores de 12.1 ou 14.2 , por exemplo.
Por omissão o step é null (ou vazio) 

O atributo decimal_units, por omissão é null, mas quando definido permite que se introduzam números com um determinado número de casas decimais.

O atributo autoincrement é um boleano. Quando a true, assume que quando é apresentada uma opção e New ou Edit (ou similares), se o elemento estiver por preencher (null), vai adotar o próximo número, face ao último que foi usado. Esse número é guardado ao nivel da relation no atributo .numero.autoincrement_max
O número a utilizar será .numero.autoincrement_max+1 e depois atualizamos .numero.autoincrement_max para esse número. Desta forma teremos números únicos, mesmo que venha a ser apagado um registo que tinha o número máximo.

O atributo .show_spin_buttons é um booleano (por omissão a false) eserve para indicar se queremos que no campo numérico apareçam os botões spin, que permitem subir o valor introduzido por +1 ou -1. Caso esteja definido um .step, a opção deixa de ser +1 e -1 e passa a ser o step indicado.

O atributo .associated_error, que por omissão é null (ou vazio) pode ainda ter um valor referenciado de forma explícida como '5%' | '0.01' | 'input'. Quando é input, significa que será interpretado qual o erro associado àquela "leitura" específica, àquele registo, como descrevemos abaixo.

O atributo .show_thousands_separator, é um boleano, que indica se o número a apresentar deve ser formatado para usar separador de milhares, tipicamente ('.'|','|' ').

O att number tem a particularidade de ser introduzido num input de text, para ter flexibilidade na introdução de dados.

O atributo número pode ser introduzido de muitas formas de apresentação que detalho a seguir, mas todas elas obrigam a uma conversão para float. Esse valor convertido é o que é depois utilizado para as estatísticas, para as operações de comparação de filtro e similares.

O value de uma célula de um atributo number sera um objeto
{
  input:'',
  value:null,
  error:null
}

Podemos introduzir um número num input no formato a/b, ou seja como um rácio, por exemplo, 1/3, 3/5, 1/2.

O valor introduzido será guardado tal e qual como introduzido (e guardado em input), mas será mostrado numa label, o valor float convertido.

Também podemos introduzir um valor com um prexifo '0x' que indica que estamos a introduzir em hexadecimal, o que significa que a partir daí o número poderá ter algarismos e letras 'abcdef'.
O número pode ser introduzido na base 8, com o prefixo '0o', ou na base 2 com o prefixo '0b'. Enquanto está a ser introduzido, não mostra o valor convertido (guardado em value), mas ao sair do campo, mostra o valor em value, já em base 10.
Note-se que mesmo para os números em base 16, 8 ou 2, é possível ter casas decimais expressas nessas bases.

Também é possível introduzir números apresentados em notação científica, o que significa que pode ter uma base e uma mantissa, por exemplo 1.5E-3.
Desde que o formato seja válido, é mantido o valor, tal e qual o utilizador introduziu, mas convertido para o formato mais convencional e guardado em .value.

Caso o número permita erros associados (.associated_error) e na opção input, então tentará interpretar no input a existência de um erro, através do token '+-' ou '-+' que é a indicação que vamos indicar um erro em seguida. Esse token pode ser precedido de espaços, bem como ter espaços após o '+-' e antes do número propriamente dito.
As regras e as variantes indicadas para representar o número são também usadas para interpretar o número do erro.
Caso o erro seja configurado de forma geral, em % ou com valor fixo, então, o seu valor é determinado e o valor guardado em .error
Caso a opção de erro que esteja a ser utilizada seja um valor fixo, então o valor guardado em value, tem de ser ajustado para um múltiplo do erro, com arredondamento. 
Na apresentação em label, se .associated_error for diferente de null, então aparece, em base 10, o .value+' +- '+.error

Caso no .group a opção tenha sido valores complexos, então existira à frente do primeiro número um 'i', ou o primeiro número ser a parte real, seguida de '+', como ou sem espaços antes e depois, seguido de um número com 'i'. O 'i' da parte complexa deve vir junto ao final do número sem nenhum espaço.
Ainda poderá existir um erro, que também pode ser expresso como um número complexo. 
